// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: hugo.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/twpayne/go-geom"
	"highway-sign-portal-builder/pkg/types"
)

const getHugoCounties = `-- name: GetHugoCounties :many
SELECT id, county_name, county_slug, image_count, state_name, state_slug FROM sign.vwhugocounty WHERE image_count is not null
`

type GetHugoCountiesRow struct {
	ID         int32
	CountyName pgtype.Text
	CountySlug pgtype.Text
	ImageCount int64
	StateName  pgtype.Text
	StateSlug  pgtype.Text
}

func (q *Queries) GetHugoCounties(ctx context.Context) ([]GetHugoCountiesRow, error) {
	rows, err := q.db.Query(ctx, getHugoCounties)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHugoCountiesRow
	for rows.Next() {
		var i GetHugoCountiesRow
		if err := rows.Scan(
			&i.ID,
			&i.CountyName,
			&i.CountySlug,
			&i.ImageCount,
			&i.StateName,
			&i.StateSlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHugoCountries = `-- name: GetHugoCountries :many
SELECT id, country_name, country_slug, subdivision_name, image_count, states, featured, highway_types FROM sign.vwhugocountry
`

func (q *Queries) GetHugoCountries(ctx context.Context) ([]SignVwhugocountry, error) {
	rows, err := q.db.Query(ctx, getHugoCountries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SignVwhugocountry
	for rows.Next() {
		var i SignVwhugocountry
		if err := rows.Scan(
			&i.ID,
			&i.CountryName,
			&i.CountrySlug,
			&i.SubdivisionName,
			&i.ImageCount,
			&i.States,
			&i.Featured,
			&i.HighwayTypes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHugoFeatureLinks = `-- name: GetHugoFeatureLinks :many
SELECT id, from_feature, to_feature, road_name, highways, to_point, from_point, highway_name FROM sign.vwhugofeaturelink
`

func (q *Queries) GetHugoFeatureLinks(ctx context.Context) ([]SignVwhugofeaturelink, error) {
	rows, err := q.db.Query(ctx, getHugoFeatureLinks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SignVwhugofeaturelink
	for rows.Next() {
		var i SignVwhugofeaturelink
		if err := rows.Scan(
			&i.ID,
			&i.FromFeature,
			&i.ToFeature,
			&i.RoadName,
			&i.Highways,
			&i.ToPoint,
			&i.FromPoint,
			&i.HighwayName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHugoFeatures = `-- name: GetHugoFeatures :many
SELECT id, cast(point as geometry), name, cast(signs as text[]), state_name, state_slug, country_name, country_slug, highway_names FROM sign.vwhugofeature
`

type GetHugoFeaturesRow struct {
	ID           int32
	Point        geom.Point
	Name         pgtype.Text
	Signs        []string
	StateName    pgtype.Text
	StateSlug    pgtype.Text
	CountryName  pgtype.Text
	CountrySlug  pgtype.Text
	HighwayNames []string
}

func (q *Queries) GetHugoFeatures(ctx context.Context) ([]GetHugoFeaturesRow, error) {
	rows, err := q.db.Query(ctx, getHugoFeatures)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHugoFeaturesRow
	for rows.Next() {
		var i GetHugoFeaturesRow
		if err := rows.Scan(
			&i.ID,
			&i.Point,
			&i.Name,
			&i.Signs,
			&i.StateName,
			&i.StateSlug,
			&i.CountryName,
			&i.CountrySlug,
			&i.HighwayNames,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHugoHighwayNames = `-- name: GetHugoHighwayNames :many
select hn.id, slugify(hn.name) as slug, hn.name, aas.name as state_name, aas.slug as state_slug from sign.highway_name hn inner join sign.admin_area_state aas on hn.state_id = aas.id
`

type GetHugoHighwayNamesRow struct {
	ID        int32
	Slug      string
	Name      pgtype.Text
	StateName pgtype.Text
	StateSlug pgtype.Text
}

func (q *Queries) GetHugoHighwayNames(ctx context.Context) ([]GetHugoHighwayNamesRow, error) {
	rows, err := q.db.Query(ctx, getHugoHighwayNames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHugoHighwayNamesRow
	for rows.Next() {
		var i GetHugoHighwayNamesRow
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Name,
			&i.StateName,
			&i.StateSlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHugoHighwaySigns = `-- name: GetHugoHighwaySigns :many
SELECT id, title, sign_description, feature_id, date_taken, imageid, flickrid, point, country_slug, state_slug, place_slug, county_slug, tags, categories, highways, is_to, image_height, image_width, quality FROM sign.vwhugohighwaysign
`

func (q *Queries) GetHugoHighwaySigns(ctx context.Context) ([]SignVwhugohighwaysign, error) {
	rows, err := q.db.Query(ctx, getHugoHighwaySigns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SignVwhugohighwaysign
	for rows.Next() {
		var i SignVwhugohighwaysign
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.SignDescription,
			&i.FeatureID,
			&i.DateTaken,
			&i.Imageid,
			&i.Flickrid,
			&i.Point,
			&i.CountrySlug,
			&i.StateSlug,
			&i.PlaceSlug,
			&i.CountySlug,
			&i.Tags,
			&i.Categories,
			&i.Highways,
			&i.IsTo,
			&i.ImageHeight,
			&i.ImageWidth,
			&i.Quality,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHugoHighwayTypes = `-- name: GetHugoHighwayTypes :many
SELECT id, highway_type_name, highway_type_slug, sort, coalesce(imagecount,0), imageid, cast(highways as text[]), country FROM sign.vwhugohighwaytype
`

type GetHugoHighwayTypesRow struct {
	ID              int32
	HighwayTypeName pgtype.Text
	HighwayTypeSlug pgtype.Text
	Sort            pgtype.Int4
	Imagecount      int64
	Imageid         *types.ImageID
	Highways        []string
	Country         pgtype.Text
}

func (q *Queries) GetHugoHighwayTypes(ctx context.Context) ([]GetHugoHighwayTypesRow, error) {
	rows, err := q.db.Query(ctx, getHugoHighwayTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHugoHighwayTypesRow
	for rows.Next() {
		var i GetHugoHighwayTypesRow
		if err := rows.Scan(
			&i.ID,
			&i.HighwayTypeName,
			&i.HighwayTypeSlug,
			&i.Sort,
			&i.Imagecount,
			&i.Imageid,
			&i.Highways,
			&i.Country,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHugoHighways = `-- name: GetHugoHighways :many
SELECT id, highway_name, slug, sort_number, image_name, highway_type_slug, highway_type_name, cast (states as text[]), cast (counties as text[]), cast (places as text[]), cast (previous_features as int[]), cast (next_features as int[]), display_name FROM sign.vwhugohighway
`

type GetHugoHighwaysRow struct {
	ID               int32
	HighwayName      pgtype.Text
	Slug             pgtype.Text
	SortNumber       pgtype.Int4
	ImageName        pgtype.Text
	HighwayTypeSlug  pgtype.Text
	HighwayTypeName  pgtype.Text
	States           []string
	Counties         []string
	Places           []string
	PreviousFeatures []int32
	NextFeatures     []int32
	DisplayName      pgtype.Text
}

func (q *Queries) GetHugoHighways(ctx context.Context) ([]GetHugoHighwaysRow, error) {
	rows, err := q.db.Query(ctx, getHugoHighways)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHugoHighwaysRow
	for rows.Next() {
		var i GetHugoHighwaysRow
		if err := rows.Scan(
			&i.ID,
			&i.HighwayName,
			&i.Slug,
			&i.SortNumber,
			&i.ImageName,
			&i.HighwayTypeSlug,
			&i.HighwayTypeName,
			&i.States,
			&i.Counties,
			&i.Places,
			&i.PreviousFeatures,
			&i.NextFeatures,
			&i.DisplayName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHugoPlaces = `-- name: GetHugoPlaces :many
SELECT id, place_name, place_slug, image_count, state_name, state_slug FROM sign.vwhugoplace where image_count is not null
`

type GetHugoPlacesRow struct {
	ID         int32
	PlaceName  pgtype.Text
	PlaceSlug  pgtype.Text
	ImageCount int64
	StateName  pgtype.Text
	StateSlug  pgtype.Text
}

func (q *Queries) GetHugoPlaces(ctx context.Context) ([]GetHugoPlacesRow, error) {
	rows, err := q.db.Query(ctx, getHugoPlaces)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHugoPlacesRow
	for rows.Next() {
		var i GetHugoPlacesRow
		if err := rows.Scan(
			&i.ID,
			&i.PlaceName,
			&i.PlaceSlug,
			&i.ImageCount,
			&i.StateName,
			&i.StateSlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHugoStates = `-- name: GetHugoStates :many
SELECT id, state_name, state_slug, subdivision_name, image_count, highways, featured, country_slug, counties, places, categories, highway_names FROM sign.vwhugostate
`

type GetHugoStatesRow struct {
	ID              int32
	StateName       pgtype.Text
	StateSlug       pgtype.Text
	SubdivisionName pgtype.Text
	ImageCount      int64
	Highways        []string
	Featured        *types.ImageID
	CountrySlug     pgtype.Text
	Counties        []types.AdminArea
	Places          []types.AdminArea
	Categories      []string
	HighwayNames    []string
}

func (q *Queries) GetHugoStates(ctx context.Context) ([]GetHugoStatesRow, error) {
	rows, err := q.db.Query(ctx, getHugoStates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHugoStatesRow
	for rows.Next() {
		var i GetHugoStatesRow
		if err := rows.Scan(
			&i.ID,
			&i.StateName,
			&i.StateSlug,
			&i.SubdivisionName,
			&i.ImageCount,
			&i.Highways,
			&i.Featured,
			&i.CountrySlug,
			&i.Counties,
			&i.Places,
			&i.Categories,
			&i.HighwayNames,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHugoTags = `-- name: GetHugoTags :many
select id, name, slug, is_category, category_details from sign.tag
`

type GetHugoTagsRow struct {
	ID              int32
	Name            pgtype.Text
	Slug            pgtype.Text
	IsCategory      bool
	CategoryDetails pgtype.Text
}

func (q *Queries) GetHugoTags(ctx context.Context) ([]GetHugoTagsRow, error) {
	rows, err := q.db.Query(ctx, getHugoTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHugoTagsRow
	for rows.Next() {
		var i GetHugoTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.IsCategory,
			&i.CategoryDetails,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
